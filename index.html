<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MacOS Aqua Styled Context Menu with AI Integration</title>
  <style>
    /* -----------------------
       Basic Page Styling
       ----------------------- */

       html {
        min-width: 220px;
      }
      
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      }

      /* -----------------------
         API Key Input Section
         ----------------------- */
      #apiKeySection {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 8px;
        padding: 12px;
        backdrop-filter: blur(10px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        z-index: 1000;
        min-width: 280px;
      }
      
      .api-input-container {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 8px;
      }
      
      #apiKeyField {
        flex: 1;
        padding: 6px 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 12px;
        font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
        min-width: 0;
      }
      
      #apiKeyField:focus {
        outline: none;
        border-color: #0064e1;
      }
      
      #apiKeyField.error {
        border-color: #dc3545;
        background-color: #fff5f5;
      }
      
      .api-button {
        background: #0064e1;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 6px 12px;
        font-size: 12px;
        cursor: pointer;
        transition: background-color 0.2s;
        white-space: nowrap;
      }
      
      .api-button:hover {
        background: #0056c7;
      }
      
      .api-button.secondary {
        background: #6c757d;
      }
      
      .api-button.secondary:hover {
        background: #5a6268;
      }
      
      .api-button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      
      #apiKeyStatus {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 12px;
      }
      
      #apiKeyStatus.hidden {
        display: none;
      }
      
      #statusText {
        color: #666;
        font-weight: 500;
      }
      
      #statusText.connected {
        color: #28a745;
      }
      
      #statusText.disconnected {
        color: #dc3545;
      }
      
      .status-button {
        background: #0064e1;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 4px 8px;
        font-size: 12px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      
      .status-button:hover {
        background: #0056c7;
      }
      
      .status-button.change {
        background: #6c757d;
      }
      
      .status-button.change:hover {
        background: #5a6268;
      }
      
      /* -----------------------
         Speech Bubble
         ----------------------- */
      #speechBubble {
        position: absolute;
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid #ccc;
        border-radius: 10px;
        padding: 5px 10px;
        pointer-events: none;
        font-size: 14px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
      }
      
      /* -----------------------
         Custom Context Menu
         ----------------------- */
         #customContextMenu {
            position: absolute;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            padding: 4px 0;
            width: 240px;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
          }
          
          #customContextMenu.hidden {
            display: none;
          }
          
      
      /* -----------------------
         Menu Items
         ----------------------- */
      #menuOptions {
        margin-bottom: 4px;
      }
      
      /* Simple vertical list items */
      .menu-item {
        padding: 4px 12px;
        cursor: default;
        display: flex;
        align-items: center;
        min-height: 20px;
        color: #000;
        justify-content: space-between;
      }
      
      .shortcut {
        color: #666;
        font-size: 12px;
        margin-left: 20px;
      }
      
      .menu-item:hover {
        background-color: #0064e1;
        color: white;
      }
      
      .menu-item:hover .shortcut {
        color: rgba(255, 255, 255, 0.8);
      }
      
      .menu-separator {
        height: 1px;
        background-color: rgba(0, 0, 0, 0.1);
        margin: 4px 0;
      }
      
      /* -----------------------
         Input Group
         ----------------------- */
      .input-group {
        display: flex;
        gap: 4px;
        padding: 4px 8px;
        align-items: center;
      }
      
      #promptInput {
        flex: 1;
        padding: 6px 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 13px;
        background: rgba(255, 255, 255, 0.9);
      }
      
      #promptInput:focus {
        outline: none;
        border-color: #0064e1;
      }
      
      /* -----------------------
         Buttons
         ----------------------- */
      .mac-aqua-button {
        padding: 4px 10px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s ease;
        white-space: nowrap;
      }
      
      .aqua-button-grey {
        background: linear-gradient(to bottom, #f8f8f8, #e8e8e8);
        border: 1px solid #ccc;
        color: #333;
      }
      
      .aqua-button-blue {
        background: #0064e1;
        border: none;
        color: white;
      }
      
      .aqua-button-blue:hover {
        background: #0056c7;
      }
      
      /* -----------------------
         AI Response
         ----------------------- */
      #aiResponse {
        margin: 4px 8px;
        padding: 8px;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.9);
        font-size: 13px;
        max-height: 300px;
        overflow-y: auto;
      }
      
      #aiResponse.hidden {
        display: none;
      }
      
      .loading {
        text-align: center;
        color: #666;
        padding: 8px;
        font-size: 13px;
      }
      
      .loading.hidden {
        display: none;
      }
      
      .response-text {
        font-size: 13px;
        line-height: 1.4;
        white-space: pre-wrap;
      }
      
      /* -----------------------
         Screenshot Preview
         ----------------------- */
      #screenshotPreview {
        margin: 4px 8px;
        text-align: center;
      }
      
      #screenshotPreview img {
        max-width: 100%;
        border-radius: 4px;
        border: 1px solid rgba(0, 0, 0, 0.1);
      }
      
      /* -----------------------
         Selection Box (Right-Click Drag)
         ----------------------- */
      .selection-box {
        position: absolute;
        border: 2px dashed #0064e1;
        background: rgba(0, 100, 225, 0.1);
        pointer-events: none;
        z-index: 999;
      }
      
      /* -----------------------
         Inspector Panel
         ----------------------- */
      #inspectorPanel {
        position: fixed;
        right: 20px;
        top: 80px;
        width: 300px;
        background: rgba(255, 255, 255, 0.98);
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        font-size: 13px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(0, 0, 0, 0.1);
        z-index: 10000;
      }
      
      #inspectorPanel.hidden {
        display: none;
      }
      
      .inspector-header {
        padding: 8px 12px;
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(247, 247, 247, 0.9);
        border-radius: 8px 8px 0 0;
      }
      
      .close-button {
        border: none;
        background: none;
        font-size: 20px;
        color: #666;
        cursor: pointer;
        padding: 0 4px;
      }
      
      .close-button:hover {
        color: #000;
      }
      
      .inspector-content {
        padding: 12px;
      }
      
      .element-path {
        font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
        color: #0064e1;
        margin-bottom: 8px;
        word-break: break-all;
      }
      
      .element-attributes {
        margin-bottom: 8px;
      }
      
      .element-styles {
        margin-bottom: 12px;
        max-height: 200px;
        overflow-y: auto;
      }
      
      .inspector-tip {
        padding: 8px;
        background: rgba(0, 100, 225, 0.1);
        border-radius: 4px;
        color: #0064e1;
        font-size: 12px;
        text-align: center;
      }
      
      /* Highlight for inspected element */
      .highlight-inspect {
        outline: 2px solid #0064e1 !important;
        outline-offset: -1px !important;
        background-color: rgba(0, 100, 225, 0.1) !important;
      }

      /* -----------------------
         NEW: AI Response Bubbles
         ----------------------- */
      .ai-response-bubble {
        position: absolute;
        width: 32px;
        height: 32px;
        background: linear-gradient(135deg, #0064e1, #0056c7);
        border-radius: 50%;
        cursor: pointer;
        z-index: 500;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 12px rgba(0, 100, 225, 0.3);
        transition: all 0.3s ease;
        border: 2px solid rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(5px);
      }

      .ai-response-bubble:hover {
        transform: scale(1.1);
        box-shadow: 0 4px 20px rgba(0, 100, 225, 0.4);
      }

      .ai-response-bubble::before {
        content: '"';
        color: white;
        font-size: 18px;
        font-weight: bold;
        font-family: Georgia, serif;
      }

      .ai-response-bubble.loading {
        animation: pulse 1.5s infinite;
        background: linear-gradient(135deg, #6c757d, #5a6268);
      }

      .ai-response-bubble.loading::before {
        content: '⋯';
        font-size: 14px;
        animation: dots 1.5s infinite;
      }

      @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
      }

      @keyframes dots {
        0%, 20% { opacity: 0; }
        50% { opacity: 1; }
        80%, 100% { opacity: 0; }
      }

      /* -----------------------
         NEW: AI Conversation Panel
         ----------------------- */
      .ai-conversation-panel {
        position: absolute;
        background: rgba(255, 255, 255, 0.98);
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        backdrop-filter: blur(15px);
        border: 1px solid rgba(0, 0, 0, 0.1);
        z-index: 1001;
        width: 450px;
        height: 500px;
        display: flex;
        flex-direction: column;
        transform: scale(0.8);
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        overflow: hidden;
      }

      .ai-conversation-panel.visible {
        transform: scale(1);
        opacity: 1;
      }

      .ai-conversation-panel.minimized {
        height: 50px;
      }

      .ai-conversation-panel.minimized .ai-conversation-messages,
      .ai-conversation-panel.minimized .ai-conversation-input {
        display: none;
      }

      .ai-conversation-header {
        padding: 12px 16px;
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        background: rgba(0, 100, 225, 0.05);
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
      }

      .ai-conversation-title {
        font-weight: 600;
        color: #0064e1;
        font-size: 14px;
      }

      .ai-conversation-controls {
        display: flex;
        gap: 4px;
      }

      .ai-conversation-minimize,
      .ai-conversation-close {
        border: none;
        background: none;
        font-size: 16px;
        color: #666;
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 4px;
        transition: all 0.2s ease;
        line-height: 1;
      }

      .ai-conversation-minimize:hover,
      .ai-conversation-close:hover {
        background: rgba(0, 0, 0, 0.1);
        color: #000;
      }

      .ai-conversation-messages {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .message {
        max-width: 85%;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .user-message {
        align-self: flex-end;
      }

      .ai-message {
        align-self: flex-start;
      }

      .message-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
        font-size: 11px;
        color: #666;
        margin-bottom: 2px;
      }

      .user-message .message-header {
        flex-direction: row-reverse;
      }

      .message-role {
        font-weight: 600;
      }

      .user-message .message-role {
        color: #0064e1;
      }

      .ai-message .message-role {
        color: #28a745;
      }

      .message-content {
        padding: 10px 14px;
        border-radius: 16px;
        line-height: 1.4;
        font-size: 14px;
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .user-message .message-content {
        background: #0064e1;
        color: white;
        border-bottom-right-radius: 6px;
      }

      .ai-message .message-content {
        background: rgba(0, 0, 0, 0.05);
        color: #333;
        border-bottom-left-radius: 6px;
      }

      .ai-conversation-input {
        border-top: 1px solid rgba(0, 0, 0, 0.1);
        padding: 16px;
        background: rgba(247, 247, 247, 0.9);
        flex-shrink: 0;
      }

      .input-container {
        display: flex;
        gap: 8px;
        align-items: flex-end;
        margin-bottom: 8px;
      }

      .input-container textarea {
        flex: 1;
        border: 1px solid #ddd;
        border-radius: 12px;
        padding: 10px 14px;
        font-size: 14px;
        font-family: inherit;
        resize: none;
        min-height: 20px;
        max-height: 120px;
        background: white;
        transition: border-color 0.2s;
      }

      .input-container textarea:focus {
        outline: none;
        border-color: #0064e1;
      }

      .input-container textarea:disabled {
        background: #f5f5f5;
        color: #666;
      }

      .send-button {
        background: #0064e1;
        color: white;
        border: none;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        flex-shrink: 0;
      }

      .send-button:hover:not(:disabled) {
        background: #0056c7;
        transform: scale(1.05);
      }

      .send-button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      .send-icon {
        font-size: 16px;
        font-weight: bold;
      }

      .loading-dots {
        font-size: 18px;
        animation: dots 1.5s infinite;
      }

      .input-actions {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
      }

      .action-button {
        background: none;
        border: 1px solid #ddd;
        color: #666;
        padding: 4px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s ease;
      }

      .action-button:hover {
        background: rgba(0, 0, 0, 0.05);
        border-color: #999;
        color: #333;
      }

      .clear-btn:hover {
        border-color: #dc3545;
        color: #dc3545;
      }
  </style>
  <!-- Include html2canvas from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>

    I'm really excited to talk to you. I was sitting in the audience yesterday as you were announcing Alexa Plus. I have a lot of questions about how it works, the feature set, where do you think it's going. But it occurred to me, as I was sitting there watching you present it, and then later as I was watching some of the demos of it working, that to make it happen had to have required some big structure and culture rethinks inside of Amazon itself.

You joined about a year and a half ago. Decoder is all about structure and culture rethinks. So there's a lot here. There's a product to talk about, but then there's the path of getting to that product. Is that how you see it? That you had to reset some parts of Amazon to get to Alexa Plus?

I don't think resetting Amazon; Amazon's incredibly ambitious in so many ways. Always learning, changing. I mean it's pretty powerful. I think resetting the devices team a little bit, yeah. First off, we hadn't really had a large-scale event, as I understand it — obviously, I wasn't there — since pre-pandemic.

The events under your predecessor, Dave Limp, they were entertaining in a way. It was, here's a firehose of stuff with Alexa in it. Microwave, a coffee maker. We would count, maybe, like, they announced 45 products.

Yesterday, you announced one new product, Alexa Plus and no new hardware, and that's a pretty big difference.

I think that was important. So yeah, I guess that's a change for sure from what it's been. What we did yesterday as a team, it was a little bit of a reset. The team was pumped to do it, excited. We were never going to announce hardware. It wasn't a goal. We need to reset Alexa for the world, and bring Alexa Plus forward. That is a bit of a cultural shift. We're just going to focus on the service and what it's going to be.

Great products are coming. We already have great products in market. We launched stuff at the holiday. And the team, they rallied. The company rallied. It's pretty awesome. Having [Amazon CEO] Andy [Jassy] there is fantastic. And you can feel a vibe in that room for sure. I hope you did. I mean, you made your snarky comment about the music when you got in there. Man, we check every detail. I think I missed, I may have missed, I don't know...

The chiptune rave music? It was pretty good. I always wonder who sets the playlist, 'cause you can do a lot with music in the pre-show.

Every single part of that show after the moment the mic starts has been very, very well thought through. Yesterday's event was the highest risk event I've ever done. I mean, bar none.

I mean, I watched you reintroduce laptops at Microsoft in competition with your partners.

It doesn't compare.

Really? Why so risky?

Because when you're basically doing hardware, you have fallbacks. The demos aren't, they're not not live, but you always can just go to the hardware. When you're reinventing or re-architecting an entire service, there's no backup. It was the product. I think the only product video we had, like actual video, was the kids' portion. Because, honestly, you're not kids in the audience. So sharing a kids feature without some emotion is a waste of time. It's like, here's a kid feature, please write about it. So putting a little bit of emotion and storytelling in it.

Those were all real demos. That all really happened. That was one of the principles of the event. It wasn't like, let's go make up a fake story and we'll just put film. That was the one area where it was just, it wasn't a vision piece, it was the product, but it was the only area that wasn't live. And so there was a lot of trepidation. This was the hardest kind of event we've put together, risk profile-wise.

  <!-- API Key Input Section -->
  <div id="apiKeySection">
    <div id="apiKeyInput" class="api-input-container">
      <input type="password" id="apiKeyField" placeholder="Enter OpenAI API Key (sk-...)" />
      <button id="saveApiKey" class="api-button">Save</button>
      <button id="testApiKey" class="api-button secondary">Test</button>
    </div>
    <div id="apiKeyStatus" class="hidden">
      <span id="statusText">✅ API Key Active</span>
      <button id="changeApiKey" class="status-button">Change</button>
    </div>
  </div>

  <!-- A simple speech bubble following the mouse -->
  <div id="speechBubble">Hello!</div>

  <!-- Custom context menu -->
  <div id="customContextMenu" class="hidden">
    <div id="menuOptions">
      <div class="menu-item" data-action="cut">Cut</div>
      <div class="menu-item" data-action="copy">Copy</div>
      <div class="menu-item" data-action="paste">Paste</div>
      <div class="menu-separator"></div>
      <div class="menu-item" data-action="inspect">Inspect Element <span class="shortcut">⌘⌥I</span></div>
    </div>
    <div class="menu-separator"></div>
    <div class="input-group">
      <input type="text" id="promptInput" placeholder="Ask AI about this...">
      <button id="sendToAI" class="mac-aqua-button aqua-button-blue">Ask</button>
    </div>
    <div id="screenshotPreview"></div>
    <div id="aiResponse" class="hidden">
      <div class="loading hidden">Processing...</div>
      <div class="response-text"></div>
    </div>
  </div>

  <!-- Inspector Panel -->
  <div id="inspectorPanel" class="hidden">
    <div class="inspector-header">
      <span>Element Inspector</span>
      <button class="close-button">×</button>
    </div>
    <div class="inspector-content">
      <div class="element-path"></div>
      <div class="element-attributes"></div>
      <div class="element-styles"></div>
      <div class="inspector-tip">
        Press ⌘⌥I (Mac) or Ctrl+Shift+I (Windows) to open Chrome DevTools
      </div>
    </div>
  </div>

  <script>
    // Global variables to store screenshot data
    let screenshotDataURL = null;
    let isSelecting = false;
    let startX, startY;
    let selectionBox = null;

    // Store the element under the right click
    let lastRightClickedElement = null;
    let lastRightClickX = 0;
    let lastRightClickY = 0;

    // Store the currently inspected element
    let inspectedElement = null;

    // NEW: Store AI response bubbles
    let responseBubbles = [];
    let bubbleCounter = 0;
    let activeConversationPanel = null;

    // Configuration
    const OPENAI_API_ENDPOINT = 'https://api.openai.com/v1/chat/completions';

    // API Key storage (in-memory for this session)
    let apiKey = null;

    // Get device pixel ratio
    const dpr = window.devicePixelRatio || 1;

    // Update API key status display
    function updateApiKeyStatus() {
      const inputContainer = document.getElementById('apiKeyInput');
      const statusDiv = document.getElementById('apiKeyStatus');
      const statusText = document.getElementById('statusText');
      
      if (apiKey) {
        inputContainer.classList.add('hidden');
        statusDiv.classList.remove('hidden');
        statusText.textContent = '✅ API Key Active';
      } else {
        inputContainer.classList.remove('hidden');
        statusDiv.classList.add('hidden');
      }
    }

    // Validate API key format
    function isValidApiKeyFormat(key) {
      return key && key.trim().startsWith('sk-') && key.trim().length > 20;
    }

    // Test API key with a simple request
    async function testApiKey(key) {
      try {
        const response = await fetch('https://api.openai.com/v1/models', {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${key}`,
            'Content-Type': 'application/json'
          }
        });
        
        return response.ok;
      } catch (error) {
        return false;
      }
    }

    // NEW: Create AI response bubble
    function createResponseBubble(x, y, prompt, isLoading = true) {
      const bubbleId = `bubble-${bubbleCounter++}`;
      const bubble = document.createElement('div');
      bubble.className = 'ai-response-bubble' + (isLoading ? ' loading' : '');
      bubble.id = bubbleId;
      bubble.style.left = (x - 16) + 'px';
      bubble.style.top = (y - 16) + 'px';
      
      document.body.appendChild(bubble);
      
      const bubbleData = {
        id: bubbleId,
        element: bubble,
        x: x,
        y: y,
        conversation: [
          {
            role: 'user',
            content: prompt,
            timestamp: new Date()
          }
        ],
        isLoading: isLoading
      };
      
      responseBubbles.push(bubbleData);
      
      // Add click handler for bubble
      bubble.addEventListener('click', () => {
        if (!bubbleData.isLoading) {
          showConversationPanel(bubbleData);
        }
      });
      
      return bubbleData;
    }

    // NEW: Update bubble when response arrives
    function updateResponseBubble(bubbleData, response) {
      bubbleData.conversation.push({
        role: 'assistant',
        content: response,
        timestamp: new Date()
      });
      bubbleData.isLoading = false;
      bubbleData.element.classList.remove('loading');
    }

    // NEW: Show conversation panel (replaces showResponsePanel)
    function showConversationPanel(bubbleData) {
      // Close any existing conversation panel
      if (activeConversationPanel) {
        activeConversationPanel.classList.remove('visible');
        setTimeout(() => activeConversationPanel.remove(), 300);
      }
      
      const panel = document.createElement('div');
      panel.className = 'ai-conversation-panel';
      activeConversationPanel = panel;
      
      panel.innerHTML = `
        <div class="ai-conversation-header">
          <span class="ai-conversation-title">AI Conversation</span>
          <div class="ai-conversation-controls">
            <button class="ai-conversation-minimize">−</button>
            <button class="ai-conversation-close">×</button>
          </div>
        </div>
        <div class="ai-conversation-messages" id="messages-${bubbleData.id}">
          ${renderConversationHistory(bubbleData.conversation)}
        </div>
        <div class="ai-conversation-input">
          <div class="input-container">
            <textarea id="continue-input-${bubbleData.id}" placeholder="Continue the conversation..." rows="2"></textarea>
            <button class="send-button" data-bubble-id="${bubbleData.id}">
              <span class="send-icon">→</span>
            </button>
          </div>
          <div class="input-actions">
            <button class="action-button clear-btn" data-bubble-id="${bubbleData.id}">Clear History</button>
            <button class="action-button copy-btn" data-bubble-id="${bubbleData.id}">Copy All</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(panel);
      
      // Position panel near the bubble but avoid screen edges
      positionConversationPanel(panel, bubbleData);
      
      // Show with animation
      setTimeout(() => panel.classList.add('visible'), 10);
      
      // Focus the input
      const input = panel.querySelector(`#continue-input-${bubbleData.id}`);
      input.focus();
      
      // Add event handlers
      setupConversationPanelHandlers(panel, bubbleData);
    }
    
    function renderConversationHistory(conversation) {
      return conversation.map((message, index) => {
        const timeStr = message.timestamp.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const isUser = message.role === 'user';
        return `
          <div class="message ${isUser ? 'user-message' : 'ai-message'}">
            <div class="message-header">
              <span class="message-role">${isUser ? 'You' : 'AI'}</span>
              <span class="message-time">${timeStr}</span>
            </div>
            <div class="message-content">${message.content}</div>
          </div>
        `;
      }).join('');
    }
    
    function positionConversationPanel(panel, bubbleData) {
      const bubbleRect = bubbleData.element.getBoundingClientRect();
      const panelWidth = 450;
      const panelHeight = 500;
      
      let panelX = bubbleRect.right + 15;
      let panelY = bubbleRect.top - 10;
      
      // Adjust for screen boundaries
      if (panelX + panelWidth > window.innerWidth) {
        panelX = bubbleRect.left - panelWidth - 15;
      }
      if (panelY + panelHeight > window.innerHeight) {
        panelY = window.innerHeight - panelHeight - 20;
      }
      if (panelX < 10) panelX = 10;
      if (panelY < 10) panelY = 10;
      
      panel.style.left = panelX + 'px';
      panel.style.top = panelY + 'px';
    }
    
    function setupConversationPanelHandlers(panel, bubbleData) {
      const input = panel.querySelector(`#continue-input-${bubbleData.id}`);
      const sendBtn = panel.querySelector(`.send-button[data-bubble-id="${bubbleData.id}"]`);
      const closeBtn = panel.querySelector('.ai-conversation-close');
      const minimizeBtn = panel.querySelector('.ai-conversation-minimize');
      const clearBtn = panel.querySelector(`.clear-btn[data-bubble-id="${bubbleData.id}"]`);
      const copyBtn = panel.querySelector(`.copy-btn[data-bubble-id="${bubbleData.id}"]`);
      const messagesContainer = panel.querySelector(`#messages-${bubbleData.id}`);
      
      // Send message function
      const sendMessage = async () => {
        const message = input.value.trim();
        if (!message) return;
        
        // Add user message to conversation
        bubbleData.conversation.push({
          role: 'user',
          content: message,
          timestamp: new Date()
        });
        
        // Clear input and show loading
        input.value = '';
        input.disabled = true;
        sendBtn.disabled = true;
        sendBtn.innerHTML = '<span class="loading-dots">⋯</span>';
        
        // Re-render messages
        messagesContainer.innerHTML = renderConversationHistory(bubbleData.conversation);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
        try {
          // Get AI response with conversation context
          const response = await continueConversation(bubbleData.conversation);
          
          // Add AI response to conversation
          bubbleData.conversation.push({
            role: 'assistant',
            content: response,
            timestamp: new Date()
          });
          
          // Re-render messages
          messagesContainer.innerHTML = renderConversationHistory(bubbleData.conversation);
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
          
        } catch (error) {
          // Add error message
          bubbleData.conversation.push({
            role: 'assistant',
            content: `Error: ${error.message}`,
            timestamp: new Date()
          });
          messagesContainer.innerHTML = renderConversationHistory(bubbleData.conversation);
        } finally {
          // Re-enable input
          input.disabled = false;
          sendBtn.disabled = false;
          sendBtn.innerHTML = '<span class="send-icon">→</span>';
          input.focus();
        }
      };
      
      // Event listeners
      sendBtn.addEventListener('click', sendMessage);
      
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });
      
      closeBtn.addEventListener('click', () => {
        panel.classList.remove('visible');
        setTimeout(() => {
          panel.remove();
          if (activeConversationPanel === panel) {
            activeConversationPanel = null;
          }
        }, 300);
      });
      
      minimizeBtn.addEventListener('click', () => {
        panel.classList.toggle('minimized');
      });
      
      clearBtn.addEventListener('click', () => {
        if (confirm('Are you sure you want to clear this conversation history?')) {
          // Keep only the first message (original prompt)
          bubbleData.conversation = bubbleData.conversation.slice(0, 1);
          messagesContainer.innerHTML = renderConversationHistory(bubbleData.conversation);
        }
      });
      
      copyBtn.addEventListener('click', async () => {
        const conversationText = bubbleData.conversation
          .map(msg => `${msg.role === 'user' ? 'You' : 'AI'}: ${msg.content}`)
          .join('\n\n');
        
        try {
          await navigator.clipboard.writeText(conversationText);
          copyBtn.textContent = 'Copied!';
          setTimeout(() => copyBtn.textContent = 'Copy All', 2000);
        } catch (err) {
          console.error('Failed to copy:', err);
        }
      });
      
      // Auto-resize textarea
      input.addEventListener('input', () => {
        input.style.height = 'auto';
        input.style.height = Math.min(input.scrollHeight, 120) + 'px';
      });
      
      // Close when clicking outside
      setTimeout(() => {
        document.addEventListener('click', function outsideClickHandler(e) {
          if (!panel.contains(e.target) && !bubbleData.element.contains(e.target)) {
            panel.classList.remove('visible');
            setTimeout(() => {
              panel.remove();
              if (activeConversationPanel === panel) {
                activeConversationPanel = null;
              }
            }, 300);
            document.removeEventListener('click', outsideClickHandler);
          }
        });
      }, 100);
    }
    
    // NEW: Continue conversation with AI
    async function continueConversation(conversation) {
      try {
        const apiKey = await getApiKey();
        if (!apiKey) {
          throw new Error("API key is required");
        }

        // Build messages array for OpenAI
        const messages = [
          {
            role: "system",
            content: "You are a helpful assistant. Continue the conversation naturally based on the context provided."
          },
          ...conversation.map(msg => ({
            role: msg.role === 'user' ? 'user' : 'assistant',
            content: msg.content
          }))
        ];

        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: "gpt-4o",
            messages: messages,
            max_tokens: 500
          })
        });

        if (!response.ok) {
          throw new Error(`API request failed: ${response.statusText}`);
        }

        const data = await response.json();
        return data.choices[0].message.content;
        
      } catch (error) {
        throw error;
      }
    }

    // Initialize status on page load
    document.addEventListener('DOMContentLoaded', () => {
      updateApiKeyStatus();
      
      const apiKeyField = document.getElementById('apiKeyField');
      const saveButton = document.getElementById('saveApiKey');
      const testButton = document.getElementById('testApiKey');
      const changeButton = document.getElementById('changeApiKey');
      
      // Save API key
      saveButton.addEventListener('click', async () => {
        const key = apiKeyField.value.trim();
        
        if (!isValidApiKeyFormat(key)) {
          apiKeyField.classList.add('error');
          apiKeyField.placeholder = 'Invalid format! Must start with sk-';
          return;
        }
        
        apiKeyField.classList.remove('error');
        saveButton.disabled = true;
        saveButton.textContent = 'Saving...';
        
        try {
          // Test the API key
          const isValid = await testApiKey(key);
          
          if (isValid) {
            apiKey = key;
            apiKeyField.value = '';
            updateApiKeyStatus();
          } else {
            apiKeyField.classList.add('error');
            apiKeyField.placeholder = 'Invalid API key! Check your key.';
          }
        } catch (error) {
          apiKeyField.classList.add('error');
          apiKeyField.placeholder = 'Error testing key. Try again.';
        }
        
        saveButton.disabled = false;
        saveButton.textContent = 'Save';
      });
      
      // Test API key without saving
      testButton.addEventListener('click', async () => {
        const key = apiKeyField.value.trim();
        
        if (!isValidApiKeyFormat(key)) {
          apiKeyField.classList.add('error');
          apiKeyField.placeholder = 'Invalid format! Must start with sk-';
          return;
        }
        
        apiKeyField.classList.remove('error');
        testButton.disabled = true;
        testButton.textContent = 'Testing...';
        
        try {
          const isValid = await testApiKey(key);
          
          if (isValid) {
            testButton.textContent = '✅ Valid';
            setTimeout(() => {
              testButton.textContent = 'Test';
              testButton.disabled = false;
            }, 2000);
          } else {
            testButton.textContent = '❌ Invalid';
            setTimeout(() => {
              testButton.textContent = 'Test';
              testButton.disabled = false;
            }, 2000);
          }
        } catch (error) {
          testButton.textContent = '❌ Error';
          setTimeout(() => {
            testButton.textContent = 'Test';
            testButton.disabled = false;
          }, 2000);
        }
      });
      
      // Change API key
      changeButton.addEventListener('click', () => {
        apiKey = null;
        updateApiKeyStatus();
        apiKeyField.focus();
      });
      
      // Enter key to save
      apiKeyField.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          // Trigger the save button click (which is already async)
          saveButton.click();
        }
        // Clear error state on typing
        if (apiKeyField.classList.contains('error')) {
          apiKeyField.classList.remove('error');
          apiKeyField.placeholder = 'Enter OpenAI API Key (sk-...)';
        }
      });
    });

    // Prevent the default context menu and store clicked element
    document.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      lastRightClickedElement = e.target;
      lastRightClickX = e.clientX;
      lastRightClickY = e.clientY;
      
      // Check if we have selected text and populate the input field
      const selectedText = getSelectedText();
      if (selectedText.trim()) {
        populatePromptWithSelection(selectedText);
      }
      
      // Show context menu immediately for text selection
      if (selectedText.trim() && !isSelecting) {
        showContextMenu(e.clientX, e.clientY);
      }
    });

    // --- Speech Bubble ---
    document.addEventListener("mousemove", (e) => {
      const speechBubble = document.getElementById("speechBubble");
      speechBubble.style.left = (e.pageX + 15) + "px";
      speechBubble.style.top = (e.pageY + 15) + "px";
    });

    // Helper function to get selected text
    function getSelectedText() {
      return window.getSelection().toString();
    }

    // Helper function to populate prompt input with selected text
    function populatePromptWithSelection(selectedText) {
      const promptInput = document.getElementById("promptInput");
      const currentValue = promptInput.value.trim();
      
      // If input is empty, add the selected text
      if (!currentValue) {
        promptInput.value = `Explain this text: "${selectedText}"`;
      } else {
        // If input has content, append the selected text
        promptInput.value = currentValue + `\n\nSelected text: "${selectedText}"`;
      }
      
      // Focus the input for immediate editing
      promptInput.focus();
      promptInput.setSelectionRange(promptInput.value.length, promptInput.value.length);
    }

    // Helper function to show context menu
    function showContextMenu(x, y, hasScreenshot = false) {
      const customMenu = document.getElementById("customContextMenu");
      const previewContainer = document.getElementById("screenshotPreview");
      
      // Clear old screenshot preview if no new screenshot
      if (!hasScreenshot) {
        previewContainer.innerHTML = "";
        screenshotDataURL = null;
      }
      
      // Position the context menu
      customMenu.style.left = x + "px";
      customMenu.style.top = y + "px";
      customMenu.classList.remove("hidden");
      
      // Focus the prompt input if it has content
      const promptInput = document.getElementById("promptInput");
      if (promptInput.value.trim()) {
        setTimeout(() => promptInput.focus(), 100);
      }
    }

    // Helper function to insert text at cursor position
    function insertTextAtCursor(element, text) {
      const start = element.selectionStart;
      const end = element.selectionEnd;
      const before = element.value.substring(0, start);
      const after = element.value.substring(end);
      element.value = before + text + after;
      element.selectionStart = element.selectionEnd = start + text.length;
    }

    // Update the menu options click handler
    document.getElementById("menuOptions").addEventListener("click", async function(e) {
      if (e.target && e.target.matches(".menu-item")) {
        const action = e.target.getAttribute("data-action");
        const selectedText = getSelectedText();
        
        switch(action) {
          case "cut":
            if (selectedText) {
              try {
                await navigator.clipboard.writeText(selectedText);
                // If the selection is in an input/textarea, remove the text
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                  const el = document.activeElement;
                  const start = el.selectionStart;
                  const end = el.selectionEnd;
                  el.value = el.value.slice(0, start) + el.value.slice(end);
                }
              } catch (err) {
                console.error('Failed to cut text:', err);
              }
            }
            break;

          case "copy":
            if (selectedText) {
              try {
                await navigator.clipboard.writeText(selectedText);
              } catch (err) {
                console.error('Failed to copy text:', err);
              }
            }
            break;

          case "paste":
            try {
              const text = await navigator.clipboard.readText();
              if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                insertTextAtCursor(document.activeElement, text);
              }
            } catch (err) {
              console.error('Failed to paste text:', err);
            }
            break;

          case "inspect":
            showInspector(lastRightClickedElement);
            simulateInspectShortcut().catch(console.error);
            break;
        }
        
        // Hide the context menu after action
        document.getElementById("customContextMenu").classList.add("hidden");
      }
    });

    // --- Right-Click Drag Selection & Screenshot ---
    document.addEventListener("mousedown", (e) => {
      if (e.button === 2) { // Right-click
        // Only start selection if we don't have selected text
        const selectedText = getSelectedText();
        if (!selectedText.trim()) {
          isSelecting = true;
          startX = e.pageX;
          startY = e.pageY;
          selectionBox = document.createElement("div");
          selectionBox.className = "selection-box";
          selectionBox.style.left = startX + "px";
          selectionBox.style.top = startY + "px";
          document.body.appendChild(selectionBox);
        }
      }
    });

    document.addEventListener("mousemove", (e) => {
      if (isSelecting && selectionBox) {
        const currentX = e.pageX;
        const currentY = e.pageY;
        const x = Math.min(currentX, startX);
        const y = Math.min(currentY, startY);
        const width = Math.abs(currentX - startX);
        const height = Math.abs(currentY - startY);
        selectionBox.style.left = x + "px";
        selectionBox.style.top = y + "px";
        selectionBox.style.width = width + "px";
        selectionBox.style.height = height + "px";
      }
    });

    document.addEventListener("mouseup", async (e) => {
      if (isSelecting && e.button === 2) {
        isSelecting = false;

        // Get the bounding rectangle of the selection box
        let boxRect = selectionBox.getBoundingClientRect();
        // Remove the selection box from the DOM
        document.body.removeChild(selectionBox);
        selectionBox = null;

        // Enforce minimum selection area of 10×10
        if (boxRect.width < 10 || boxRect.height < 10) {
          showContextMenu(e.pageX, e.pageY);
          return;
        }

        try {
          // Calculate the scaled dimensions
          const scaledWidth = boxRect.width * dpr;
          const scaledHeight = boxRect.height * dpr;

          // Create canvas with device pixel ratio
          const canvas = await html2canvas(document.body, {
            scale: dpr,
            useCORS: true,
            logging: false,
            windowWidth: document.documentElement.offsetWidth,
            windowHeight: document.documentElement.offsetHeight
          });

          const croppedCanvas = document.createElement("canvas");
          croppedCanvas.width = scaledWidth;
          croppedCanvas.height = scaledHeight;
          
          const ctx = croppedCanvas.getContext("2d");
          ctx.scale(dpr, dpr);
          
          // Draw the scaled and cropped image
          ctx.drawImage(
            canvas,
            boxRect.left * dpr, boxRect.top * dpr, scaledWidth, scaledHeight,
            0, 0, boxRect.width, boxRect.height
          );

          // Get the screenshot data URL
          screenshotDataURL = croppedCanvas.toDataURL("image/png");

          // Create preview image with correct CSS dimensions
          const previewContainer = document.getElementById("screenshotPreview");
          previewContainer.innerHTML = "";
          const img = document.createElement("img");
          img.src = screenshotDataURL;
          img.style.width = Math.min(boxRect.width, 200) + "px";
          img.style.height = Math.min(boxRect.height, 150) + "px";
          img.style.objectFit = "contain";
          previewContainer.appendChild(img);

          // Update prompt input with screenshot context
          const promptInput = document.getElementById("promptInput");
          if (!promptInput.value.trim()) {
            promptInput.value = "Analyze this screenshot and explain what you see.";
          }

          // Show context menu with screenshot
          showContextMenu(
            boxRect.left + boxRect.width / 2,
            boxRect.top + boxRect.height / 2,
            true
          );
        } catch (error) {
          console.error('Error capturing screenshot:', error);
          showContextMenu(e.pageX, e.pageY);
        }
      }
    });

    document.addEventListener("click", (e) => {
      const customMenu = document.getElementById("customContextMenu");
      if (!customMenu.contains(e.target)) {
        customMenu.classList.add("hidden");
        // Clear the prompt input when menu is hidden
        document.getElementById("promptInput").value = "";
      }
    });

    // --- Clipboard Options Functionality ---
    // Add mousedown/up listeners to switch button states.
    const buttons = document.querySelectorAll("#menuOptions .mac-aqua-button");
    buttons.forEach(button => {
      button.addEventListener("mousedown", () => {
        button.classList.remove("aqua-button-grey");
        button.classList.add("aqua-button-blue");
      });
      button.addEventListener("mouseup", () => {
        button.classList.remove("aqua-button-blue");
        button.classList.add("aqua-button-grey");
      });
      button.addEventListener("mouseleave", () => {
        button.classList.remove("aqua-button-blue");
        button.classList.add("aqua-button-grey");
      });
    });

    // --- Prompt Input "Send" Action ---
    document.getElementById("promptInput").addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        const prompt = e.target.value.trim();
        if (prompt) {
          sendToOpenAI(prompt, screenshotDataURL);
        }
      }
    });

    // --- Speech-to-Text on Right-Click within Prompt Input ---
    const promptInput = document.getElementById("promptInput");
    promptInput.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        console.log("Speech Recognition API not supported in this browser.");
        return;
      }
      const recognition = new SpeechRecognition();
      recognition.lang = 'en-US';
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.start();
      console.log("Speech recognition started...");
      recognition.onresult = function(event) {
        let transcript = event.results[0][0].transcript;
        const start = promptInput.selectionStart;
        const end = promptInput.selectionEnd;
        const before = promptInput.value.substring(0, start);
        const after = promptInput.value.substring(end);
        promptInput.value = before + transcript + after;
        const newPos = start + transcript.length;
        promptInput.setSelectionRange(newPos, newPos);
        console.log("Speech recognition result:", transcript);
      };
      recognition.onerror = function(event) {
        console.error("Speech recognition error:", event.error);
      };
    });

    // Function to get or prompt for API key
    async function getApiKey() {
      if (apiKey) {
        return apiKey;
      }
      
      // Create a custom modal for API key input
      return new Promise((resolve, reject) => {
        // Create modal elements
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 10001;
          backdrop-filter: blur(5px);
        `;
        
        const modalContent = document.createElement('div');
        modalContent.style.cssText = `
          background: white;
          padding: 30px;
          border-radius: 12px;
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
          width: 400px;
          max-width: 90vw;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        `;
        
        modalContent.innerHTML = `
          <h3 style="margin: 0 0 20px 0; color: #333; font-size: 18px;">Enter OpenAI API Key</h3>
          <p style="margin: 0 0 20px 0; color: #666; font-size: 14px; line-height: 1.4;">
            To use the AI features, please enter your OpenAI API key. You can get one from 
            <a href="https://platform.openai.com/api-keys" target="_blank" style="color: #0064e1;">platform.openai.com</a>
          </p>
          <input type="password" id="apiKeyInput" placeholder="sk-..." style="
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            box-sizing: border-box;
            margin-bottom: 20px;
          ">
          <div style="display: flex; gap: 10px; justify-content: flex-end;">
            <button id="cancelApiKey" style="
              padding: 8px 16px;
              border: 1px solid #ddd;
              background: #f5f5f5;
              border-radius: 6px;
              cursor: pointer;
              font-size: 14px;
            ">Cancel</button>
            <button id="saveApiKey" style="
              padding: 8px 16px;
              border: none;
              background: #0064e1;
              color: white;
              border-radius: 6px;
              cursor: pointer;
              font-size: 14px;
            ">Save & Continue</button>
          </div>
        `;
        
        modal.appendChild(modalContent);
        document.body.appendChild(modal);
        
        const input = modal.querySelector('#apiKeyInput');
        const saveBtn = modal.querySelector('#saveApiKey');
        const cancelBtn = modal.querySelector('#cancelApiKey');
        
        // Focus the input
        input.focus();
        
        // Handle save
        const handleSave = () => {
          const key = input.value.trim();
          if (key) {
            apiKey = key;
            document.body.removeChild(modal);
            resolve(key);
          } else {
            input.style.borderColor = '#ff4444';
            input.placeholder = 'Please enter a valid API key';
          }
        };
        
        // Handle cancel
        const handleCancel = () => {
          document.body.removeChild(modal);
          reject(new Error('API key required'));
        };
        
        // Event listeners
        saveBtn.addEventListener('click', handleSave);
        cancelBtn.addEventListener('click', handleCancel);
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            handleSave();
          } else if (e.key === 'Escape') {
            handleCancel();
          }
        });
        
        // Click outside to cancel
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            handleCancel();
          }
        });
      });
    }

    // MODIFIED: Updated sendToOpenAI function to create response bubbles
    async function sendToOpenAI(prompt, screenshot) {
      // Create loading bubble at the right-click location
      const bubble = createResponseBubble(lastRightClickX, lastRightClickY, prompt, true);
      
      // Hide the context menu
      document.getElementById("customContextMenu").classList.add("hidden");
      
      try {
        const apiKey = await getApiKey();
        if (!apiKey) {
          throw new Error("API key is required");
        }

        let messages = [
          {
            role: "system",
            content: "You are a helpful assistant analyzing text and images."
          },
          {
            role: "user",
            content: prompt
          }
        ];

        if (screenshot) {
          messages.push({
            role: "user",
            content: [
              {
                type: "image_url",
                image_url: {
                  url: screenshot
                }
              }
            ]
          });
        }

        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: "gpt-4o",
            messages: messages,
            max_tokens: 500
          })
        });

        if (!response.ok) {
          throw new Error(`API request failed: ${response.statusText}`);
        }

        const data = await response.json();
        const aiResponse = data.choices[0].message.content;
        
        // Update the bubble with the response
        updateResponseBubble(bubble, aiResponse);
        
      } catch (error) {
        // Update bubble with error message
        updateResponseBubble(bubble, `Error: ${error.message}`);
      }
      
      // Clear the prompt input
      document.getElementById("promptInput").value = "";
    }

    // Handle send button click
    document.getElementById("sendToAI").addEventListener("click", () => {
      const prompt = document.getElementById("promptInput").value;
      if (prompt.trim()) {
        sendToOpenAI(prompt, screenshotDataURL);
      }
    });

    // Helper function to get element path
    function getElementPath(element) {
      const path = [];
      while (element && element.nodeType === Node.ELEMENT_NODE) {
        let selector = element.tagName.toLowerCase();
        if (element.id) {
          selector += '#' + element.id;
        } else if (element.className) {
          selector += '.' + Array.from(element.classList).join('.');
        }
        path.unshift(selector);
        element = element.parentNode;
      }
      return path.join(' > ');
    }

    // Helper function to get computed styles
    function getElementStyles(element) {
      const computed = window.getComputedStyle(element);
      const important = ['display', 'position', 'width', 'height', 'margin', 'padding', 'color', 'background-color', 'font-size', 'font-family'];
      const styles = {};
      important.forEach(prop => {
        styles[prop] = computed[prop];
      });
      return styles;
    }

    // Helper function to get element attributes
    function getElementAttributes(element) {
      const attributes = {};
      for (let attr of element.attributes) {
        attributes[attr.name] = attr.value;
      }
      return attributes;
    }

    // Function to show inspector panel
    function showInspector(element) {
      const panel = document.getElementById('inspectorPanel');
      const pathDiv = panel.querySelector('.element-path');
      const attributesDiv = panel.querySelector('.element-attributes');
      const stylesDiv = panel.querySelector('.element-styles');

      // Remove previous highlight
      if (inspectedElement) {
        inspectedElement.classList.remove('highlight-inspect');
      }

      // Highlight new element
      inspectedElement = element;
      element.classList.add('highlight-inspect');

      // Update path
      pathDiv.textContent = getElementPath(element);

      // Update attributes
      const attrs = getElementAttributes(element);
      attributesDiv.innerHTML = Object.entries(attrs)
        .map(([key, value]) => `<div><strong>${key}</strong>: ${value}</div>`)
        .join('');

      // Update styles
      const styles = getElementStyles(element);
      stylesDiv.innerHTML = Object.entries(styles)
        .map(([prop, value]) => `<div><strong>${prop}</strong>: ${value};</div>`)
        .join('');

      panel.classList.remove('hidden');
    }

    // Close inspector panel
    document.querySelector('#inspectorPanel .close-button').addEventListener('click', () => {
      const panel = document.getElementById('inspectorPanel');
      panel.classList.add('hidden');
      if (inspectedElement) {
        inspectedElement.classList.remove('highlight-inspect');
        inspectedElement = null;
      }
    });

    // Helper function to detect OS
    function isMac() {
      return navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    }

    // Function to simulate keyboard shortcut
    async function simulateInspectShortcut() {
      const isMacOS = isMac();
      
      try {
        // Method 1: Chrome DevTools Protocol
        if (window.chrome && window.chrome.devtools) {
          await window.chrome.devtools.inspectedWindow.eval(
            `inspect(document.querySelector('${getElementPath(lastRightClickedElement)}'))`
          );
          return;
        }

        // Method 2: Keyboard Event
        const event = new KeyboardEvent('keydown', {
          key: 'i',
          code: 'KeyI',
          keyCode: 73,
          which: 73,
          altKey: isMacOS,
          metaKey: isMacOS,
          ctrlKey: !isMacOS,
          shiftKey: !isMacOS,
          bubbles: true
        });
        document.dispatchEvent(event);

        // Method 3: Direct function call (works in some browsers)
        if (typeof window.__devtoolsOpenFunction === 'function') {
          window.__devtoolsOpenFunction();
          return;
        }

        // Method 4: Debug URL (Chrome)
        const debugUrl = `javascript:(function() { 
          setTimeout(function() {
            debugger;
          }, 100);
        })();`;
        const debugLink = document.createElement('a');
        debugLink.href = debugUrl;
        debugLink.click();
        
      } catch (error) {
        console.log('Could not automatically open DevTools. Please use the keyboard shortcut:', 
          isMacOS ? '⌘⌥I' : 'Ctrl+Shift+I');
      }
    }
  </script>
</body>
</html>